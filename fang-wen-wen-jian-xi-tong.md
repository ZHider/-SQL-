# 访问文件系统

在本节中，我将介绍如何利用 SQL 注入获取后端 DBMS 底层文件系统的读写权限。 根据配置的不同，这种方法可能非常复杂，而且可能需要注意数据库管理系统架构和网络应用程序施加的限制。

## 读取权限

在渗透测试期间，对被入侵机器上文件的读取权限可能非常有用：它可能导致信息泄露，帮助攻击者实施进一步攻击，因为它可能导致敏感用户的信息泄露。

### MySQL

MySQL 有一个内置函数，允许读取底层文件系统上的文本或二进制文件：`LOAD_FILE()`。会话用户必须拥有以下对支持表[^support_table]的权限：`FILE` 和 `CREATE TABLE` 权限（仅在堆叠查询时需要）。在 Linux 和 UNIX 系统上，文件必须由启动 MySQL 进程的用户（通常是 `mysql`）拥有，或者该文件所有用户都可读。在 Windows 系统中，MySQL 默认以本地系统身份运行，因此可以通过数据库管理系统读取任何现有文件。

可以通过 UNION 查询、盲注或基于错误的 SQL 注入技术检索文件内容。不过，在调用 `LOAD_FILE()` 函数时需要考虑一些限制：

* 如果添加文件内容的列数据类型为 varchar，则显示的文件字符最大长度为 5000；
* 通过基于错误的 SQL 注入技术检索文件时，文件内容在很多情况下会被截断为几个字符；
* 文件可以是二进制格式（如 Linux 上的 ELF 或 Windows 上的可执行文件），而且根据网络应用程序语言的不同，无法通过 UNION 查询或基于错误的 SQL 注入技术在页面内容中显示。

绕过这些限制的步骤：

* 通过分批查询：
  * 创建一个有一个字段、数据类型为 `longtext` 的支持表；
  * 使用 `LOAD_FILE()` 函数读取文件内容，并通过 `INTO DUMPFILE` 将相应的十六进制编码字符串值重定向到临时文件中；
  * 使用 `LOAD DATA INFILE` 将临时文件内容加载到支持表中。

* 通过其他 SQL 注入技术：
  * 读取支持表的字段值的长度；
  * 以 1024 个字符为单位转储支持表的字段值。

现在需要将这些字符串组合成一个十六进制编码字符串，然后解码并写入本地文件。

[^support_table]: 译注：支持表（support table），指在注入行为中，为了达成最终目的而创建的临时（或非临时）的数据表，一般用于数据处理和中转。

### PostgreSQL

PostgreSQL 有一个内置语句，允许将文本文件从底层文件系统复制到表的文本字段：`COPY`。

1. 会话用户必须是 “超级用户”才能调用该语句。
2. &#x20;文件必须归启动 PostgreSQL 进程的用户（通常是 `postgres`）所有，或者是全部用户可读的。

可以通过 UNION 查询、盲注或基于错误的 SQL 注入技术检索文件内容。不过，网络应用程序编程语言必须支持分批查询。 具体步骤如下

* 通过分批查询：
  * 创建一个有一个字段、数据类型为 `bytea` 的支持表；
  * 使用 `COPY` 语句将文本文件的内容加载到支持表中。

* 通过任何其他 SQL 注入技术：
  * 计算支持表中的条目数；
  * 通过 `ENCODE` 函数将支持表的字段条目转为 base64 编码。

现在，需要将转储的条目组装成一个 base64 编码字符串，然后将其解码并写入本地文件。

自 PostgreSQL 7.4 起，`COPY` 语句就不能用来读取二进制文件了：不过可以用一个自定义的用户定义函数来读取二进制文件。这个用户自定义函数输入二进制文件，并将其内容以十六进制编码字符串的形式输出到临时文本文件中。然后，攻击者就可以如上所述读取该文本文件。

### Microsoft SQL Server

Microsoft SQL Server 有一个内置语句，允许将文件系统中的文本或二进制文件内容插入到表的 `VARCHAR` 字段中：`BULK INSERT`。

会话用户必须具有以下权限： `INSERT`、`ADMINISTER BULK OPERATIONS` 和 `CREATE TABLE`。

Microsoft SQL Server 2000 默认以管理员身份运行，因此数据库管理系统可以读取任何现有文件。如果数据库管理员将 Microsoft SQL Server 2005 和 2008 配置为以本地系统 (`SYSTEM`) 或管理员身份运行，则情况也一样，否则文件必须是所有用户可读的，而这在 Windows 上很普遍。

可以通过 UNION 查询、盲注或基于错误的 SQL 注入技术检索文件内容。不过，网络应用程序编程语言必须支持批量查询。

步骤如下：

* 通过堆叠查询：
  * 创建一个支持表（表1） ，其中包含一个字段，数据类型为 `text`；
  * 创建另一个支持表（表2） ，其中包含两个字段，一个是数据类型 `INT IDENTITY (1,1) PRIMARY KEY`，另一个是数据类型 `VARCHAR (4096)` ;
  * 使用 `BULK INSERT` 语句将文件内容作为一个条目载入表1；
  * 注入 SQL 代码，将支持表（表1）的条目转换为其十六进制编码，然后将编码过后的字符串 `INSERT` 进支持表（表2）的每个条目，每一条长 4096 字符。

* 通过任何其他 SQL 注入技术:
  * 计算表2中的条目数量；
  * 转储支持表 table2 的 `varchar` 字段条目，这些条目按 `PRIMARY KEY` 字段排序。这些条目最终需要组装成一个单一的十六进制编码字符串，然后解码并写入本地文件。

## 写入权限

渗透测试成功的一个有力证据就是在底层文件系统上写入的能力，以及执行任意命令的能力。这一点将在本文后面解释。

### MySQL

MySQL 有一个内置的 `SELECT` 子句，它允许将数据输出到一个文件中: `INTO DUMPFILE`。会话用户必须具有以下权限: 支持表的 `FILE` 和 `INSERT`、 `UPDATE` 和 `CREATETABLE` (仅批量查询需要)。

创建的文件始终是全局可写的。在 Linux 和 UNIX 系统上，它属于启动 MySQL 进程的用户(通常是 `MySQL`)。在 Windows 上，MySQL 默认作为本地系统运行，所有人都可以阅读该文件。
该文件可以通过 UNION 查询或批查询 SQL 注入技术编写。尽管如此，在使用 UNION 查询技术时还是有一些限制需要考虑：

* 如果注入点位于 GET 参数上，一些网络服务器会对参数请求的长度施加限制;
* 无法通过 `INTO DUMPFILE` 子句将数据追加到现有文件。

然而，如果 Web 应用程序支持使用 MySQL 作为后端 DBMS 的批处理查询，则可以绕过这些限制: ASP.NET 就是这些编程语言之一。
步骤如下:

* 攻击者环境下:
  * 将本地文件内容编码为相应的十六进制字符串;
  * 将十六进制编码的字符串分割成 1024 字符长度的块。

* 通过批量查询:
  * 创建一个支持表，其中包含一个字段，数据类型为 `longblob`；
  * 将第一个块 `INSERT` 到支持表的字段中；
  * `UPDATE` 支持表的字段，在条目后面追加从第二个到最后一个的数据块;
  * 使用 `SELECT` 的 `INTO DUMPFILE` 子句将十六进制编码的文件内容从支持表的条目导出到目标文件路径。
  这是可能的，因为在 MySQL 上，像 `SELECT 0x41` 这样的查询返回相应的 ASCII 字符 `A`。

通过检索所写文件的 `LENGTH` 值，可以检查文件是否已正确写入。值得注意的是，当 Web 应用程序语言为 ASP 和 PHP 时，也可以使用 UNION 查询 SQL 注入技术将文件上传到数据库服务器，因为它们默认不支持批处理查询。

### PostgreSQL

PostgreSQL 有处理大型对象的本地函数：`lo_create()`、`lo_export()` 和 `lo_unlink()`。这些函数的设计目的是通过指针（称为 OID）在数据库中存储大型文件或引用本地文件，然后将其复制到文件系统中的其他文件。然而，这些函数很有可能被滥用——通过 SQL 注入在底层文件系统上成功写入文本和二进制文件，即使源文件在攻击者机器上。

会话用户必须是“超级用户”才能处理大型对象。在 Linux 和 UNIX 系统中，创建的文件权限设置为 644，由启动 PostgreSQL 进程的用户（通常是 `postgres`）拥有。在 Windows 系统中，PostgreSQL 默认以 `postgres` 运行，因此文件所有者是 postgres。

该文件只能通过批量查询 SQL 注入技术写入。步骤如下：

- 在攻击者的计算机上
  - 将本地文件内容编码为相应的 base64 字符串；
  - 将 base64 编码字符串分割成每块长 1024 个字符的字符串。

- 通过批量查询：
  - 创建带有一个字段，数据类型为 `text` 的支持表；
  - 在支持表的字段中 `INSERT` 第一个数据块；
  - `UPDATE` 支持表的字段，在条目中追加从第二个到最后一个的数据块；
  - 创建具有特定 OID 的大型对象；
  - 通过将数据字段值设置为支持表字段项的解码后的值，`UPDATE` 与我们的 OID 相对应的 `pg_largeobject` 系统表项；
  - 通过 `lo_export()` 将 OID 对应的数据导出到目标文件路径。<br/>
  请注意，`lo_export()` 只将 `pg_largeobject` 表的前 8192 字节导出到目标文件，但这并不限制本文后面描述的任何攻击。
  
通过检索与我们的 OID 相对应的表 `data` 字段的 `LENGTH` 值，可以检查原始文件内容是否已正确写入 `pg_largeobject` 表。如果写入的文件小于 8192 字节，则该值与写入文件的大小相同。

### Microsoft SQL Server

Microsoft SQL Server 有一个在底层操作系统上运行命令的本地扩展存储过程： `xp_cmdshell()` 。该扩展存储过程可用于执行 `echo` 命令，并将其文本参数重定向到文件。有关该扩展存储过程的详细信息，请参阅第 8.1.1 节。

会话用户必须拥有 `CONTROL SERVER` 权限才能调用此扩展存储过程。
创建的文件归启动 Microsoft SQL Server 进程的用户所有，并且是无限制读的。

步骤如下：

- 在攻击环境中：
  - 将要上传的文件分割成 65280 字节（`debug` 脚本文件大小限制）的块；
  - 将每个分块转换为纯文本 `debug` 脚本格式。

- 通过批量查询：
  - 对于每个纯文本块的 `debug` 脚本：
    - 通过 `xp_cmdshell()` 执行 echo 命令，将 `debug` 脚本的所有行输出到临时文件中； 
    - 通过 `xp_cmdshell()` 调用 Windows 可执行文件 `debug`，从上传的 `debug` 脚本中重新创建块； 
    - 删除这个临时的 `debug` 脚本。
  - 使用 Windows 可执行文件 `copy` 组装块，重新创建原始文件；
  - 将组装好的文件移动到目标路径。
  
可以检查文件是否已正确写入。通过批量查询的步骤如下：

- 创建一个有一个字段、数据类型为 `text` 的支持表；
- 使用 `BULK INSERT` 语句将文件内容作为单个条目加载到支持表中；
- 读取支持表第一个条目的 `DATALENGTH` 值。


